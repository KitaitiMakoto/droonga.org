msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"Plugin: Handle requests on all partitions, to add a new command workin"
"g around the storage\"\n"
"layout: en\n"
"---"
msgstr ""

msgid ""
"* TOC\n"
"{:toc}"
msgstr ""

msgid "## The goal of this tutorial"
msgstr "## チュートリアルのゴール"

msgid ""
"This tutorial aims to help you to learn how to develop plugins which do someth"
"ing dispersively for/in each partition, around the handling phase.\n"
"In other words, this tutorial describes *how to add a new simple command to th"
"e Droonga Engine*."
msgstr ""

msgid "## Precondition"
msgstr "## 前提条件"

msgid "* You must complete the [tutorial for the adaption phase][adapter]."
msgstr ""

msgid "## Handling of requests"
msgstr ""

msgid ""
"When a request is transferred from the adaption phase, the Droonga Engine ente"
"rs into the *processing phase*."
msgstr ""

msgid ""
"In the processing phase, the Droonga Engine processes the request step by step"
".\n"
"One *step* is constructed from some sub phases: *planning phase*, *distributio"
"n phase*, *handling phase*, and *collection phase*."
msgstr ""

msgid ""
" * At the *planning phase*, the Droonga Engine generates multiple sub steps to"
" process the request.\n"
"   In simple cases, you don't have to write codes for this phase, then there i"
"s just one sub step to handle the request.\n"
" * At the *distribution phase*, the Droonga Engine distributes task messages f"
"or the request, to multiple partitions.\n"
"   (It is completely done by the Droonga Engine itself, so this phase is not p"
"luggable.)\n"
" * At the *handling phase*, *each partition simply processes only one distribu"
"ted task message as its input, and returns a result.*\n"
"   This is the time that actual storage accesses happen.\n"
"   Actually, some commands (`search`, `add`, `create_table` and so on) access "
"to the storage at the time.\n"
" * At the *collection phase*, the Droonga Engine collects results from partiti"
"ons to one unified result.\n"
"   There are some useful generic collectors, so you don't have to write codes "
"for this phase in most cases."
msgstr ""

msgid ""
"After all steps are finished, the Droonga Engine transfers the result to the p"
"ost adaption phase."
msgstr ""

msgid ""
"A class to define operations at the handling phase is called *handler*.\n"
"Put simply, adding of a new handler means adding a new command."
msgstr ""

msgid "## Design a read-only command `countRecords`"
msgstr ""

msgid ""
"Here, in this tutorial, we are going to add a new custom `countRecords` comman"
"d.\n"
"At first, let's design it."
msgstr ""

msgid ""
"The command reports the number of records about a specified table, for each pa"
"rtition.\n"
"So it will help you to know how records are distributed in the cluster.\n"
"Nothing is changed by the command, so it is a *read-only command*."
msgstr ""

msgid "The request must have the name of one table, like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"dataset\" : \"Starbucks\",\n"
"  \"type\"    : \"countRecords\",\n"
"  \"body\"    : {\n"
"    \"table\": \"Store\"\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Create a JSON file `count-records.json` with the content above.\n"
"We'll use it for testing."
msgstr ""

msgid ""
"The response must have number of records in the table, for each partition.\n"
"They can be appear in an array, like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"inReplyTo\": \"(message id)\",\n"
"  \"statusCode\": 200,\n"
"  \"type\": \"countRecords.result\",\n"
"  \"body\": [10, 10]\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"If there are 2 partitions and 20 records are stored evenly, the array will hav"
"e two elements like above.\n"
"It means that a partition has 10 records and another one also has 10 records."
msgstr ""

msgid ""
"We're going to create a plugin to accept such requests and return such respons"
"es."
msgstr ""

msgid "### Directory structure"
msgstr ""

msgid ""
"The directory structure for plugins are in same rule as explained in the [tuto"
"rial for the adaption phase][adapter].\n"
"Now let's create the `count-records` plugin, as the file `count-records.rb`. T"
"he directory tree will be:"
msgstr ""

msgid ""
"~~~\n"
"lib\n"
"└── droonga\n"
"    └── plugins\n"
"            └── count-records.rb\n"
"~~~"
msgstr ""

msgid "Then, create a skelton of a plugin as follows:"
msgstr ""

msgid "lib/droonga/plugins/count-records.rb:"
msgstr ""

msgid ""
"~~~ruby\n"
"require \"droonga/plugin\""
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module CountRecordsPlugin\n"
"      extend Plugin\n"
"      register(\"count-records\")\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "### Define a \"step\" for the command"
msgstr ""

msgid "Define a \"step\" for the new `countRecords` command, in your plugin. Like:"
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module CountRecordsPlugin\n"
"      extend Plugin\n"
"      register(\"count-records\")"
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"The `step.name` equals to the name of the command itself.\n"
"Currently we just define the name of the command.\n"
"That's all."
msgstr ""

msgid "### Define the handling logic"
msgstr ""

msgid ""
"The command has no handler, so it does nothing yet.\n"
"Let's define the behavior."
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"        step.handler = :Handler\n"
"      end"
msgstr ""

msgid ""
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          [0]\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "The class `Handler` is a handler class for our new command."
msgstr ""

msgid ""
" * It must inherit a builtin-class `Droonga::Handler`.\n"
" * It implements the logic to handle requests.\n"
"   Its instance method `#handle` actually handles requests."
msgstr ""

msgid ""
"Currently the handler does nothing and returns an result including an array of"
" a number.\n"
"The returned value is used to construct the response body."
msgstr ""

msgid ""
"The handler is bound to the step with the configuration `step.handler`.\n"
"Because we define the class `Handler` after `define_single_step`, we specify t"
"he handler class with a symbol `:Handler`.\n"
"If you define the handler class before `define_single_step`, then you can writ"
"e as `step.handler = Handler` simply.\n"
"Moreover, a class path string like `\"OtherPlugin::Handler\"` is also available."
msgstr ""

msgid ""
"Then, we also have to bind a collector to the step, with the configuration `st"
"ep.collector`."
msgstr ""

msgid ""
"~~~ruby\n"
"# (snip)\n"
"      define_single_step do |step|\n"
"        step.name = \"countRecords\"\n"
"        step.handler = :Handler\n"
"        step.collector = Collectors::Sum\n"
"      end\n"
"# (snip)\n"
"~~~"
msgstr ""

msgid ""
"The `Collectors::Sum` is one of built-in collectors.\n"
"It merges results retuned from handler instances for each partition to one res"
"ult."
msgstr ""

msgid "### Activate the plugin with `catalog.json`"
msgstr ""

msgid ""
"Update catalog.json to activate this plugin.\n"
"Add `\"count-records\"` to `\"plugins\"`."
msgstr ""

msgid ""
"~~~\n"
"(snip)\n"
"      \"datasets\": {\n"
"        \"Starbucks\": {\n"
"          (snip)\n"
"          \"plugins\": [\"count-records\", \"groonga\", \"crud\", \"search\"],\n"
"(snip)\n"
"~~~"
msgstr ""

msgid "### Run and test"
msgstr ""

msgid ""
"Let's get Droonga started.\n"
"Note that you need to specify ./lib directory in RUBYLIB environment variable "
"in order to make ruby possible to find your plugin."
msgstr ""

msgid ""
"    # kill $(cat fluentd.pid)\n"
"    # RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon f"
"luentd.pid"
msgstr ""

msgid ""
"Then, send a request message for the `countRecords` command to the Droonga Eng"
"ine."
msgstr ""

msgid ""
"~~~\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      0,\n"
"      0,\n"
"      0\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"You'll get a response message like above.\n"
"Look at these points:"
msgstr ""

msgid ""
" * The `type` of the response becomes `countRecords.result`.\n"
"   It is automatically named by the Droonga Engine.\n"
" * The format of the `body` is same to the returned value of the handler's `ha"
"ndle` method."
msgstr ""

msgid "There are 3 elements in the array. Why?"
msgstr ""

msgid ""
" * Remember that we have configured the `Starbucks` dataset to use 3 partition"
"s (and each has 2 replicas) in the `catalog.json` of [the basic tutorial][basi"
"c].\n"
" * Because it is a read-only command, a request is delivered only to paritions"
", not to replicas.\n"
"   So there are only 3 results, not 6.\n"
"   (TODO: I have to add a figure to indicate active nodes: [000, 001, 010, 011"
", 020, 021] => [000, 011, 020])\n"
" * The `Collectors::Sum` collects them.\n"
"   Those 3 results are joined to just one array by the collector."
msgstr ""

msgid "As the result, just one array with 3 elements appears in the final response."
msgstr ""

msgid "### Read-only access to the storage"
msgstr ""

msgid ""
"Now, each instance of the handler class always returns `0` as its result.\n"
"Let's implement codes to count up the number of records from the actual storag"
"e."
msgstr ""

msgid ""
"~~~ruby\n"
"# (snip)\n"
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          request = message.request\n"
"          table_name = request[\"table\"]\n"
"          table = @context[table_name]\n"
"          count = table.size\n"
"          [count]\n"
"        end\n"
"      end\n"
"# (snip)\n"
"~~~"
msgstr ""

msgid ""
"Look at the argument of the `handle` method.\n"
"It is different from the one an adapter receives.\n"
"A handler receives a message meaning a distributed task.\n"
"So you have to extract the request message from the distributed task by the co"
"de `request = message.request`."
msgstr ""

msgid ""
"The instance variable `@context` is an instance of `Groonga::Context` for the "
"storage of the partition.\n"
"See the [class reference of Rroonga][Groonga::Context].\n"
"You can use any feature of Rroonga via `@context`.\n"
"For now, we simply access to the table itself by its name and read the value o"
"f its `size` method - it returns the number of records."
msgstr ""

msgid ""
"Then, test it.\n"
"Restart the Droonga Engine and send the request again."
msgstr ""

msgid ""
"~~~\n"
"# kill $(cat fluentd.pid)\n"
"# RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon fluen"
"td.pid\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      14,\n"
"      15,\n"
"      11\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid "Because there are totally 40 records, they are stored evenly like above."
msgstr ""

msgid "## Design a read-write command `deleteStores`"
msgstr ""

msgid "Next, let's add another new custom command `deleteStores`."
msgstr ""

msgid ""
"The command deletes records of the `Store` table, from the storage.\n"
"Because it modifies something in existing storage, it is a *read-write command"
"*."
msgstr ""

msgid "The request must have the condition to select records to be deleted, like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"dataset\" : \"Starbucks\",\n"
"  \"type\"    : \"deleteStores\",\n"
"  \"body\"    : {\n"
"    \"keyword\": \"Broadway\"\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Any record including the given keyword `\"Broadway\"` in its `\"key\"` is deleted "
"from the storage of all partitions."
msgstr ""

msgid ""
"Create a JSON file `delete-stores-broadway.json` with the content above.\n"
"We'll use it for testing."
msgstr ""

msgid "The response must have a boolean value to indicate \"success\" or \"fail\", like:"
msgstr ""

msgid ""
"~~~json\n"
"{\n"
"  \"inReplyTo\": \"(message id)\",\n"
"  \"statusCode\": 200,\n"
"  \"type\": \"deleteStores.result\",\n"
"  \"body\": true\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"If the request is successfully processed, the `body` becomes `true`. Otherwise"
" `false`.\n"
"The `body` is just one boolean value, because we don't have to receive multipl"
"e results from partitions."
msgstr ""

msgid "### Directory Structure"
msgstr ""

msgid ""
"Now let's create the `delete-stores` plugin, as the file `delete-stores.rb`. T"
"he directory tree will be:"
msgstr ""

msgid ""
"~~~\n"
"lib\n"
"└── droonga\n"
"    └── plugins\n"
"            └── delete-stores.rb\n"
"~~~"
msgstr ""

msgid "lib/droonga/plugins/delete-stores.rb:"
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module DeleteStoresPlugin\n"
"      extend Plugin\n"
"      register(\"delete-stores\")\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "Define a \"step\" for the new `deleteStores` command, in your plugin. Like:"
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module DeleteStoresPlugin\n"
"      extend Plugin\n"
"      register(\"delete-stores\")"
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"deleteStores\"\n"
"        step.write = true\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"Look at a new configuration `step.write`.\n"
"Because this command modifies the storage, we must indicate it clearly."
msgstr ""

msgid "Let's define the handler."
msgstr ""

msgid ""
"      define_single_step do |step|\n"
"        step.name = \"deleteStores\"\n"
"        step.write = true\n"
"        step.handler = :Handler\n"
"        step.collector = Collectors::And\n"
"      end"
msgstr ""

msgid ""
"      class Handler < Droonga::Handler\n"
"        def handle(message)\n"
"          request = message.request\n"
"          keyword = request[\"keyword\"]\n"
"          table = @context[\"Store\"]\n"
"          table.delete do |record|\n"
"            record.key =~ keyword\n"
"          end\n"
"          true\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"Remember, you have to extract the request message from the received task messa"
"ge."
msgstr ""

msgid ""
"The handler finds and deletes existing records which have the given keyword in"
" its \"key\", by the [API of Rroonga][Groonga::Table_delete]."
msgstr ""

msgid ""
"And, the `Collectors::And` is bound to the step by the configuration `step.col"
"lector`.\n"
"It is is also one of built-in collectors, and merges boolean values retuned fr"
"om handler instances for each partition and replica, to one boolean value."
msgstr ""

msgid ""
"Update catalog.json to activate this plugin.\n"
"Add `\"delete-stores\"` to `\"plugins\"`."
msgstr ""

msgid ""
"~~~\n"
"(snip)\n"
"      \"datasets\": {\n"
"        \"Starbucks\": {\n"
"          (snip)\n"
"          \"plugins\": [\"delete-stores\", \"count-records\", \"groonga\", \"crud\", \"se"
"arch\"],\n"
"(snip)\n"
"~~~"
msgstr ""

msgid "Restart the Droonga Engine and send the request."
msgstr ""

msgid ""
"~~~\n"
"# kill $(cat fluentd.pid)\n"
"# RUBYLIB=./lib fluentd --config fluentd.conf --log fluentd.log --daemon fluen"
"td.pid\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"deleteStores.result\",\n"
"    \"body\": true\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Because results from partitions are unified to just one boolean value, the res"
"ponse's `body` is a `true`.\n"
"As the verification, send the request of `countRecords` command."
msgstr ""

msgid ""
"~~~\n"
"# droonga-request --tag starbucks count-records.json\n"
"Elapsed time: 0.01494\n"
"[\n"
"  \"droonga.message\",\n"
"  1392621168,\n"
"  {\n"
"    \"inReplyTo\": \"1392621168.0119512\",\n"
"    \"statusCode\": 200,\n"
"    \"type\": \"countRecords.result\",\n"
"    \"body\": [\n"
"      7,\n"
"      13,\n"
"      6\n"
"    ]\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Note, the number of records are smaller than the previous result.\n"
"This means that 4 or some records are deleted from each partitions."
msgstr ""

msgid "## Conclusion"
msgstr "## まとめ"

msgid "We have learned how to create plugins work in handling phrase."
msgstr ""

msgid ""
"  [adapter]: ../adapter\n"
"  [basic]: ../basic\n"
"  [Groonga::Context]: http://ranguba.org/rroonga/en/Groonga/Context.html\n"
"  [Groonga::Table_delete]: http://ranguba.org/rroonga/en/Groonga/Table.html#de"
"lete-instance_method"
msgstr ""
