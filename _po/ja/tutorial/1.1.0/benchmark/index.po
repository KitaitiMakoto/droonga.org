msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"PO-Revision-Date: 2014-11-30 23:19+0900\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: \"How to benchmark Droonga with Groonga?\"\n"
"layout: en\n"
"---"
msgstr ""

msgid ""
"* TOC\n"
"{:toc}"
msgstr ""

msgid ""
"<!--\n"
"this is based on https://github.com/droonga/presentation-droonga-meetup-1-intr"
"oduction/blob/master/benchmark/README.md\n"
"-->"
msgstr ""

msgid "## The goal of this tutorial"
msgstr ""

msgid ""
"Learning steps to benchmark a [Droonga][] cluster and compare it to a [Groonga"
"][groonga] server."
msgstr ""

msgid "## Precondition"
msgstr ""

msgid ""
"* You must have basic knowledge and experiences to set up and operate an [Ubun"
"tu][] or [CentOS][] Server.\n"
"* You must have basic knowledge and experiences to use the [Groonga][groonga] "
"via HTTP.\n"
"* You must have basic knowledge to construct a [Droonga][] cluster.\n"
"  Please complete the [\"getting started\" tutorial](../groonga/) before this."
msgstr ""

msgid "## Why benchmarking?"
msgstr ""

msgid ""
"Because Droonga has compatibility to Groonga, you'll plan to migrate your appl"
"ication based on Groonga to Droonga.\n"
"Before that, you should benchmark Droonga and confirm that it is better altern"
"ative for your application."
msgstr ""

msgid ""
"Of course you may simply hope to know the difference in performance between Gr"
"oonga and Droonga.\n"
"Benchmarking will make it clear."
msgstr ""

msgid "### How visualize the performance?"
msgstr ""

msgid "There are two major indexes to indicate performance of a system."
msgstr ""

msgid ""
" * latency\n"
" * throughput"
msgstr ""

msgid ""
"Latency is the response time, actual elapsed time between two moments: when th"
"e system receives a request, and when it returns a response.\n"
"In other words, for clients, it is the time to wait for each request.\n"
"At this index, the smaller is the better.\n"
"In general, latency becomes small for lightweight queries, small size database"
", or less clients."
msgstr ""

msgid ""
"Throughput means how many request can be processed in a time.\n"
"The performance index is described as \"*queries per second* (*qps*)\".\n"
"For example, if a Groonga server processed 10 requests in one second, that is "
"described as \"10qps\".\n"
"Possibly there are 10 users (clients), or, there are 2 users and each user ope"
"ns 5 tabs in his web browser.\n"
"Anyway, \"10qps\" means that the Groonga actually accepted and responded for 10 "
"requests while one second is passing."
msgstr ""

msgid ""
"You can run benchmark with the command `drnbench-request-response`, introduced"
" by the Gem package [drnbench]().\n"
"It measures both latency and throughput of the target service."
msgstr ""

msgid "### How the benchmark tool measures the performance?"
msgstr ""

msgid ""
"`drnbench-request-response` benchmarks the target service, by steps like follo"
"wing:"
msgstr ""

msgid ""
" 1. The master process generates one virtual client.\n"
"    The client starts to send many requests to the target sequentially and fre"
"quently.\n"
" 2. After a while, the master process kills the client.\n"
"    Then he calculates minimum, maximum, and average elapsed time, from respon"
"se data.\n"
"    And, he counts up the number of requests actually processed by the target,"
" and reports it as \"qps\" of the single client case.\n"
" 3. The master process generates two virtual clients.\n"
"    They starts to send requests.\n"
" 4. After a while, the master process kills all clients.\n"
"    Then minimum, maximum, and average elapsed time is calculated, and total n"
"umber of processed requests sent by all clients is reported as \"qps\" of the tw"
"o clients case.\n"
" 5. Repeated with three clients, four clients ... and more progressively.\n"
" 6. Finally, the master process reports minimum/maximum/average elapsed time, "
"\"qps\", and other extra information for each case, as a CSV file like:"
msgstr ""

msgid ""
"    ~~~\n"
"    n_clients,total_n_requests,queries_per_second,min_elapsed_time,max_elapsed"
"_time,average_elapsed_time,200\n"
"    1,996,33.2,0.001773766,0.238031643,0.019765581680722916,100.0\n"
"    2,1973,65.76666666666667,0.001558398,0.272225481,0.020047345673086702,100."
"0\n"
"    4,3559,118.63333333333334,0.001531184,0.39942581,0.023357554419499882,100."
"0\n"
"    6,4540,151.33333333333334,0.001540704,0.501663069,0.042344890696916264,100"
".0\n"
"    8,4247,141.56666666666666,0.001483995,0.577100609,0.045836844514480835,100"
".0\n"
"    10,4466,148.86666666666667,0.001987089,0.604507078,0.06949704923846833,100"
".0\n"
"    12,4500,150.0,0.001782343,0.612596799,0.06902839555222215,100.0\n"
"    14,4183,139.43333333333334,0.001980711,0.60754769,0.1033681068718623,100.0"
"\n"
"    16,4519,150.63333333333333,0.00284654,0.653204575,0.09473386513387955,100."
"0\n"
"    18,4362,145.4,0.002330049,0.640683693,0.12581190483929405,100.0\n"
"    20,4228,140.93333333333334,0.003710795,0.662666076,0.1301649290901133,100."
"0\n"
"    ~~~"
msgstr ""

msgid "    You can analyze it, draw a graph from it, and so on."
msgstr ""

msgid ""
"    (Note: Performance results fluctuate from various factors.\n"
"    This is just an example on a specific version, specific environment.)"
msgstr ""

msgid "### How read and analyze the result? {#how-to-analyze}"
msgstr ""

msgid "Look at the result above."
msgstr ""

msgid "#### HTTP response statuses"
msgstr ""

msgid ""
"See the last columns named `200`.\n"
"It means the percentage of HTTP response statuses.\n"
"`200` is \"OK\", `0` is \"timed out\".\n"
"If clients got `400`, `500` and other errors, they will be also reported.\n"
"These information will help you to detect unexpected slow down."
msgstr ""

msgid "#### Latency"
msgstr ""

msgid ""
"Latency is easily analyzed - the smaller is the better.\n"
"The minimum and average elapsed time becomes small if any cache system is work"
"ing correctly on the target.\n"
"The maximum time is affected by slow queries, system's page-in/page-out, unexp"
"ected errors, and so on."
msgstr ""

msgid ""
"A graph of latency also reveals the maximum number of effectively acceptable c"
"onnections in same time."
msgstr ""

msgid "![A graph of latency](/images/tutorial/benchmark/latency-groonga-1.0.8.png)"
msgstr ""

msgid ""
"This is a graph of `average_elapsed_time`.\n"
"You'll see that the time is increased for over 4 clients.\n"
"What it means?"
msgstr ""

msgid ""
"Groonga can process multiple requests completely parallelly, until the number "
"of available processors.\n"
"When the computer has 4 processors, the system can process 4 or less requests "
"in same time, without extra latency.\n"
"And, if more requests are sent, 5th and later requests will be processed after"
" a preceding request is processed.\n"
"The graph confirms that the logical limitation is true."
msgstr ""

msgid "#### Throughput"
msgstr ""

msgid "A graph helps you to analyze throughput performance."
msgstr ""

msgid ""
"![A graph of throughput](/images/tutorial/benchmark/throughput-groonga-1.0.8.p"
"ng)"
msgstr ""

msgid ""
"You'll see that the \"qps\" stagnated around 150, for 6 or more clients.\n"
"This means that the target service can process 150 requests in one second, at "
"a maximum."
msgstr ""

msgid ""
"In other words, we can describe the result as: 150qps is the maximum throughpu"
"t performance of this system - generic performance of hardware, software, netw"
"ork, size of the database, queries, and more.\n"
"If the number of requests for your service is growing up and it is going to re"
"ach the limit, you have to do something about it - optimize queries, replace t"
"he computer with more powerful one, and so on."
msgstr ""

msgid "#### Performance comparison"
msgstr ""

msgid ""
"Sending same request patterns to Groonga and Droonga, you can compare performa"
"nce of each system.\n"
"If Droonga has better performance, it will become good reason to migrate your "
"service from Groogna to Droonga."
msgstr ""

msgid ""
"Moreover, comparing multiple results from different number of Droogna nodes, y"
"ou can analyze the cost-benefit performance for newly introduced nodes."
msgstr ""

msgid "## Prepare environments for benchmarking"
msgstr ""

msgid ""
"Assume that there are four [Ubuntu][] 14.04LTS servers for the new Droogna clu"
"ster and they can resolve their names each other:"
msgstr ""

msgid ""
" * `192.168.100.50`, the host name is `node0`\n"
" * `192.168.100.51`, the host name is `node1`\n"
" * `192.168.100.52`, the host name is `node2`\n"
" * `192.168.100.53`, the host name is `node3`"
msgstr ""

msgid "One is client, others are Droonga nodes."
msgstr ""

msgid "### Ensure an existing reference database (and the data source)"
msgstr ""

msgid ""
"If you have any existing service based on Groonga, it becomes the reference.\n"
"Then you just have to dump all data in your Groonga database and load them to "
"a new Droonga cluster."
msgstr ""

msgid ""
"Otherwise - if you have no existing service, prepare a new reference database "
"with much data for effective benchmark.\n"
"The repository [wikipedia-search][] includes some helper scripts to construct "
"your Groonga server (and Droonga cluster), with [Japanese Wikipedia](http://ja"
".wikipedia.org/) pages."
msgstr ""

msgid ""
"So let's prepare a new Groonga database including Wikipedia pages, on the `nod"
"e0`."
msgstr ""

msgid ""
" 1. Determine the size of the database.\n"
"    You have to use good enough size database for benchmarking."
msgstr ""

msgid ""
"    * If it is too small, you'll see \"too bad\" benchmark result for Droonga, b"
"ecause the percentage of the Droonga's overhead becomes relatively too large.\n"
"    * If it is too large, you'll see \"too unstable\" result because page-in and"
" page-out of RAM will slow the performance down randomly.\n"
"    * If RAM size of all nodes are different, you should determine the size of"
" the database for the minimum size RAM."
msgstr ""

msgid ""
"    For example, if there are three nodes `node0` (8GB RAM), `node1` (8GB RAM)"
", and `node2` (6GB RAM), then the database should be smaller than 6GB.\n"
" 2. Set up the Groonga server, as instructed on [the installation guide](http:"
"//groonga.org/docs/install.html)."
msgstr ""

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % sudo apt-get -y install software-properties-common\n"
"    % sudo add-apt-repository -y universe\n"
"    % sudo add-apt-repository -y ppa:groonga/ppa\n"
"    % sudo apt-get update\n"
"    % sudo apt-get -y install groonga\n"
"    ~~~"
msgstr ""

msgid ""
"    Then the Groonga becomes available.\n"
" 3. Download the archive of Wikipedia pages and convert it to a dump file for "
"Groonga, with the rake task `data:convert:groonga:ja`.\n"
"    You can specify the number of records (pages) to be converted via the envi"
"ronment variable `MAX_N_RECORDS` (default=5000)."
msgstr ""

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % cd ~/\n"
"    % git clone https://github.com/droonga/wikipedia-search.git\n"
"    % cd wikipedia-search\n"
"    % bundle install --path vendor/\n"
"    % time (MAX_N_RECORDS=1500000 bundle exec rake data:convert:groonga:ja \\\n"
"                                    data/groonga/ja-pages.grn)\n"
"    ~~~"
msgstr ""

msgid ""
"    Because the archive is very large, downloading and data conversion may tak"
"e time."
msgstr ""

msgid ""
"    After that, a dump file `~/wikipedia-search/data/groonga/ja-pages.grn` is "
"there.\n"
"    Create a new database and load the dump file to it.\n"
"    This also may take more time:"
msgstr ""

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % mkdir -p $HOME/groonga/db/\n"
"    % groonga -n $HOME/groonga/db/db quit\n"
"    % time (cat ~/wikipedia-search/config/groonga/schema.grn | groonga $HOME/g"
"roonga/db/db)\n"
"    % time (cat ~/wikipedia-search/config/groonga/indexes.grn | groonga $HOME/"
"groonga/db/db)\n"
"    % time (cat ~/wikipedia-search/data/groonga/ja-pages.grn | groonga $HOME/g"
"roonga/db/db)\n"
"    ~~~"
msgstr ""

msgid ""
"    Note: number of records affects to the database size.\n"
"    Just for information, my results are here:"
msgstr ""

msgid ""
"     * 1.1GB database was constructed from 300000 records.\n"
"       Data conversion took 17 min, data loading took 6 min.\n"
"     * 4.3GB database was constructed from 1500000 records.\n"
"       Data conversion took 53 min, data loading took 64 min."
msgstr ""

msgid " 4. Start the Groonga as an HTTP server."
msgstr ""

msgid ""
"    ~~~\n"
"    (on node0)\n"
"    % groonga -p 10041 -d --protocol http $HOME/groonga/db/db\n"
"    ~~~"
msgstr ""

msgid "OK, now we can use this node as the reference for benchmarking."
msgstr ""

msgid "### Set up a Droonga cluster"
msgstr ""

msgid ""
"Install Droonga to all nodes.\n"
"Because we are benchmarking it via HTTP, you have to install both services `dr"
"oonga-engine` and `droonga-http-server` for each node."
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% host=node0\n"
"% curl https://raw.githubusercontent.com/droonga/droonga-engine/master/install"
".sh | \\\n"
"    sudo HOST=$host bash\n"
"% curl https://raw.githubusercontent.com/droonga/droonga-http-server/master/in"
"stall.sh | \\\n"
"    sudo ENGINE_HOST=$host HOST=$host PORT=10042 bash\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1,node2\n"
"% sudo service droonga-engine start\n"
"% sudo service droonga-http-server start\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node1)\n"
"% host=node1\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node2)\n"
"% host=node2\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"Note: to start `droonga-http-server` with a port number different from Groonga"
", we should specify another port `10042` via the `PORT` environment variable, "
"like above."
msgstr ""

msgid ""
"Make sure that Droonga's HTTP server is actualy listening the port `10042` and"
" it is working as a cluster with three nodes:"
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo apt-get install -y jq\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node2:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid "### Synchronize data from Groonga to Droonga"
msgstr ""

msgid "Next, prepare the Droonga database."
msgstr ""

msgid ""
"You can generate messages for Droonga from Groonga's dump result, by the `grn2"
"drn` command.\n"
"Install `grn2drn` Gem package to activate the command, to the Groonga server c"
"omputer."
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo gem install grn2drn\n"
"~~~"
msgstr ""

msgid ""
"And, the `grndump` command introduced as a part of `rroonga` Gem package provi"
"des ability to extract all data of an existing Groonga database, flexibly.\n"
"If you are going to extract data from an existing Groonga server, you have to "
"install `rroonga` before that."
msgstr ""

msgid ""
"~~~\n"
"(on Ubuntu server)\n"
"% sudo apt-get -y install software-properties-common\n"
"% sudo add-apt-repository -y universe\n"
"% sudo add-apt-repository -y ppa:groonga/ppa\n"
"% sudo apt-get update\n"
"% sudo apt-get -y install libgroonga-dev\n"
"% sudo gem install rroonga\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on CentOS server)\n"
"# rpm -ivh http://packages.groonga.org/centos/groonga-release-1.1.0-1.noarch.r"
"pm\n"
"# yum -y makecache\n"
"# yum -y ruby-devel groonga-devel\n"
"# gem install rroonga\n"
"~~~"
msgstr ""

msgid "Then dump schemas and data separately and load them to the Droonga cluster."
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% time (grndump --no-dump-tables $HOME/groonga/db/db | \\\n"
"          grn2drn | \\\n"
"          droonga-send --server=node0 \\\n"
"                       --report-throughput)\n"
"% time (grndump --no-dump-schema --no-dump-indexes $HOME/groonga/db/db | \\\n"
"          grn2drn | \\\n"
"          droonga-send --server=node0 \\\n"
"                       --server=node1 \\\n"
"                       --server=node2 \\\n"
"                       --messages-per-second=100 \\\n"
"                       --report-throughput)\n"
"~~~"
msgstr ""

msgid ""
"Note that you must send requests for schema and indexes to just one endpoint.\n"
"Parallel sending of schema definition requests for multiple endpoints will bre"
"ak the database, because Droonga cannot sort schema changing commands sent to "
"each node in parallel."
msgstr ""

msgid ""
"To reduce traffic and system load, you should specify maximum number of inpour"
"ing messages per second by the `--messages-per-second` option.\n"
"If too many messages rush into the Droonga cluster, they may overflow - Droong"
"a may eat up the RAM and slow down the system."
msgstr ""

msgid ""
"This may take much time.\n"
"For example, with the option `--messages-per-second=100`, 1500000 records will"
" be synchronized in about 4 hours (we can estimate the required time like: `15"
"0000 / 100 / 60 / 60`)."
msgstr ""

msgid ""
"After all, now you have two HTTP servers: Groonga HTTP server with the port `1"
"0041`, and Droonga HTTP Servers with the port `10042`."
msgstr ""

msgid "### Set up the client"
msgstr ""

msgid "You must install the benchmark client to the computer."
msgstr ""

msgid "Assume that you use a computer `node3` as the client:"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% sudo apt-get update\n"
"% sudo apt-get -y upgrade\n"
"% sudo apt-get install -y ruby curl jq\n"
"% sudo gem install drnbench\n"
"~~~"
msgstr ""

msgid "## Prepare request patterns"
msgstr ""

msgid "Let's prepare request pattern files for benchmarking."
msgstr ""

msgid "### Determine the expected cache hit rate"
msgstr ""

msgid "First, you have to determine the cache hit rate."
msgstr ""

msgid ""
"If you have any existing service based on Groonga, you can get the actual cach"
"e hit rate of the Groonga database via `status` command, like:"
msgstr ""

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/status\" | jq .\n"
"[\n"
"  [\n"
"    0,\n"
"    1412326645.19701,\n"
"    3.76701354980469e-05\n"
"  ],\n"
"  {\n"
"    \"max_command_version\": 2,\n"
"    \"alloc_count\": 158,\n"
"    \"starttime\": 1412326485,\n"
"    \"uptime\": 160,\n"
"    \"version\": \"4.0.6\",\n"
"    \"n_queries\": 1000,\n"
"    \"cache_hit_rate\": 0.5,\n"
"    \"command_version\": 1,\n"
"    \"default_command_version\": 1\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"The cache hit rate appears as `\"cache_hit_rate\"`.\n"
"`0.5` means 50%, then a half of responses are returned from cached results."
msgstr ""

msgid ""
"If you have no existing service, you should assume that the cache hit rate bec"
"omes 50%."
msgstr ""

msgid ""
"To measure and compare performance of Groonga and Droonga properly, you should"
" prepare request patterns for benchmarking which make the cache hit rate near "
"the actual rate.\n"
"So, how do it?"
msgstr ""

msgid ""
"You can control the cache hit rate by the number of unique request patterns, c"
"alculated with the expression:\n"
"`N = 100 / (cache hit rate)`, because Groonga and Droonga (`droonga-http-serve"
"r`) cache 100 results at a maximum by default.\n"
"When the expected cache hit rate is 50%, the number of unique requests is calc"
"ulated as: `N = 100 / 0.5 = 200`"
msgstr ""

msgid ""
"Note: if the actual rate is near zero, the number of unique requests becomes t"
"oo huge!\n"
"For such case you should carry up the rate to 0.01 (1%) or something."
msgstr ""

msgid "### Format of request patterns file"
msgstr ""

msgid ""
"The format of the request patterns list for `drnbench-request-response` is the"
" plain text, a list of request paths for the host.\n"
"Here is a short example of requests for Groonga's `select` command:"
msgstr ""

msgid ""
"~~~\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title&output_co"
"lumns=title&query=AAA\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title&output_co"
"lumns=title&query=BBB\n"
"...\n"
"~~~"
msgstr ""

msgid ""
"If you have any existing service based on Groonga, the list should be generate"
"d from the actual access log, query log, and so on.\n"
"Patterns similar to actual requests will measure performance of your system mo"
"re effectively.\n"
"To generate 200 unique request patterns, you just have to collect 200 unique p"
"aths from your log."
msgstr ""

msgid ""
"Otherwise, you'll have to generate list of request paths from something.\n"
"See the next section."
msgstr ""

msgid "### Prepare list of search terms"
msgstr ""

msgid ""
"To generate 200 unique request patterns, you have to prepare 200 terms.\n"
"Moreover, all of terms must be effective search term for the Groonga database."
"\n"
"If you use randomly generated terms (like `P2qyNJ9L`, `Hy4pLKc5`, `D5eftuTp`, "
"...), you won't get effective benchmark result, because \"not found\" results wi"
"ll be returned for most requests."
msgstr ""

msgid ""
"So there is a utility command `drnbench-extract-searchterms`.\n"
"It generates list of terms from Groonga's select result, like:"
msgstr ""

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/select?command_version=2&table=Pages&limit=10&out"
"put_columns=title\" | \\\n"
"    drnbench-extract-searchterms\n"
"title1\n"
"title2\n"
"title3\n"
"...\n"
"title10\n"
"~~~"
msgstr ""

msgid ""
"`drnbench-extract-searchterms` extracts terms from the first column of records"
".\n"
"To collect 200 effective search terms, you just have to give a select result w"
"ith an option `limit=200`."
msgstr ""

msgid "### Generate request pattern file from given terms"
msgstr ""

msgid ""
"OK, let's generate request patterns by `drnbench-extract-searchterms`, from a "
"select result."
msgstr ""

msgid ""
"~~~\n"
"% n_unique_requests=200\n"
"% curl \"http://node0:10041/d/select?command_version=2&table=Pages&limit=$n_uni"
"que_requests&output_columns=title\" | \\\n"
"    drnbench-extract-searchterms --escape | \\\n"
"    sed -r -e \"s;^;/d/select?command_version=2\\&table=Pages\\&limit=10\\&match_c"
"olumns=title,text\\&output_columns=snippet_html(title),snippet_html(text),categ"
"ories,_key\\&query_flags=NONE\\&sortby=title\\&drilldown=categories\\&drilldown_li"
"mit=10\\&drilldown_output_columns=_id,_key,_nsubrecs\\&drilldown_sortby=_nsubrec"
"s\\&query=;\" \\\n"
"    > ./patterns.txt\n"
"~~~"
msgstr ""

msgid "Note:"
msgstr ""

msgid ""
" * You must escape `&` in the sed script with prefixed backslash, like `\\&`.\n"
" * You should specify the `--escape` option for `drnbench-extract-searchterms`"
".\n"
"   It escapes characters unsafe for URI strings.\n"
" * You should specify `query_flags=NONE` as a part of parameters, if you use s"
"earch terms by the `query` parameter.\n"
"   It forces ignoring of special characters in the `query` parameter, to Groon"
"ga.\n"
"   Otherwise you may see some errors from invalid queries."
msgstr ""

msgid "The generated file `patterns.txt` becomes like following:"
msgstr ""

msgid ""
"~~~\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title,text&outp"
"ut_columns=snippet_html(title),snippet_html(text),categories,_key&query_flags="
"NONE&sortby=title&drilldown=categories&drilldown_limit=10&drilldown_output_col"
"umns=_id,_key,_nsubrecs&drilldown_sortby=_nsubrecs&query=AAA\n"
"/d/select?command_version=2&table=Pages&limit=10&match_columns=title,text&outp"
"ut_columns=snippet_html(title),snippet_html(text),categories,_key&query_flags="
"NONE&sortby=title&drilldown=categories&drilldown_limit=10&drilldown_output_col"
"umns=_id,_key,_nsubrecs&drilldown_sortby=_nsubrecs&query=BBB\n"
"...\n"
"~~~"
msgstr ""

msgid "## Run the benchmark"
msgstr ""

msgid ""
"OK, it's ready to run.\n"
"Let's benchmark Groonga and Droonga."
msgstr ""

msgid "### Benchmark Groonga"
msgstr ""

msgid ""
"First, run benchmark for Groonga as the reference.\n"
"Start Groonga's HTTP server before running, if you configured a node as a refe"
"rence Groonga server and daemon is stopped."
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% groonga -p 10041 -d --protocol http $HOME/groonga/db/db\n"
"~~~"
msgstr ""

msgid "You can run benchmark with the command `drnbench-request-response`, like:"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0 \\\n"
"    --default-port=10041 \\\n"
"    --output-path=$PWD/groonga-result.csv\n"
"~~~"
msgstr ""

msgid "Important parameters are:"
msgstr ""

msgid ""
" * `--step` is the number of virtual clients increased on each progress.\n"
" * `--start-n-clients` is the initial number of virtual clients.\n"
"   Even if you specify `0`, initially one client is always generated.\n"
" * `--end-n-clients` is the maximum number of virtual clients.\n"
"   Benchmark is performed progressively until the number of clients is reached"
" to this limit.\n"
" * `--duration` is the duration of each benchmark.\n"
"   This should be long enough to average out the result.\n"
"   `30` (seconds) seems good for my case.\n"
" * `--interval` is the interval between each benchmark.\n"
"   This should be long enough to finish previous benchmark.\n"
"   `10` (seconds) seems good for my case.\n"
" * `--request-patterns-file` is the path to the pattern file.\n"
" * `--default-hosts` is the list of host names of target endpoints.\n"
"   By specifying multiple hosts as a comma-separated list, you can simulate lo"
"ad balancing.\n"
" * `--default-port` is the port number of the target endpoint.\n"
" * `--output-path` is the path to the result file.\n"
"   Statistics of all benchmarks is saved as a file at the location."
msgstr ""

msgid ""
"While running, you should monitor the system status of the `node0`, by `top` o"
"r something.\n"
"If the benchmark elicits Groonga's performance correctly, Groonga's process us"
"es the CPU fully (for example, `400%` on a computer with 4 processors).\n"
"Otherwise something wrong - for example, too narrow network, too low performan"
"ce client."
msgstr ""

msgid "Then you'll get the reference result of the Groonga."
msgstr ""

msgid "To confirm the result is valid, check the response of the `status` command:"
msgstr ""

msgid ""
"~~~\n"
"% curl \"http://node0:10041/d/status\" | jq .\n"
"[\n"
"  [\n"
"    0,\n"
"    1412326645.19701,\n"
"    3.76701354980469e-05\n"
"  ],\n"
"  {\n"
"    \"max_command_version\": 2,\n"
"    \"alloc_count\": 158,\n"
"    \"starttime\": 1412326485,\n"
"    \"uptime\": 160,\n"
"    \"version\": \"4.0.6\",\n"
"    \"n_queries\": 1000,\n"
"    \"cache_hit_rate\": 0.49,\n"
"    \"command_version\": 1,\n"
"    \"default_command_version\": 1\n"
"  }\n"
"]\n"
"~~~"
msgstr ""

msgid ""
"Look at the value of `\"cache_hit_rate\"`.\n"
"If it is far from the expected cache hit rate (ex. `0.5`), something wrong - f"
"or example, too few request patterns.\n"
"Too high cache hit rate produces too high throughput unexpectedly."
msgstr ""

msgid ""
"After that you should stop Groonga to release CPU and RAM resources, if it is "
"running on a Droonga node."
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% pkill groonga\n"
"~~~"
msgstr ""

msgid "### Benchmark Droonga"
msgstr ""

msgid "#### Benchmark Droonga with single node"
msgstr ""

msgid "Before benchmarking, make your cluster with only one node."
msgstr ""

msgid ""
"~~~\n"
"(on node1, node2)\n"
"% sudo service droonga-engine stop\n"
"% sudo service droonga-http-server stop\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node0)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"To clear effects from previous benchmark, you should restart services before e"
"ach test."
msgstr ""

msgid ""
"After that the endpoint `node0` works as a Droonga cluster with single node.\n"
"Make sure that only one node is actually detected:"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid "Run the benchmark."
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-1node.csv\n"
"~~~"
msgstr ""

msgid ""
"Note that the default port is changed from `10041` (Groonga's HTTP server) to "
"`10042` (Droonga).\n"
"Moreover, the path to the result file also changed."
msgstr ""

msgid ""
"While running, you should monitor the system status of the `node0`, by `top` o"
"r something.\n"
"It may help you to analyze what is the bottleneck."
msgstr ""

msgid ""
"And, to confirm the result is valid, you should check the actual cache hit rat"
"e:"
msgstr ""

msgid ""
"~~~\n"
"% curl \"http://node0:10042/statistics/cache\" | jq .\n"
"{\n"
"  \"hitRatio\": 49.830717830807124,\n"
"  \"nHits\": 66968,\n"
"  \"nGets\": 134391\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"Look at the value of `\"hitRatio\"`.\n"
"Actual cache hit rate of the HTTP server is reported in percentage like above "
"(the value `49.830717830807124` means `49.830717830807124%`.)\n"
"If it is far from the expected cache hit rate, something wrong."
msgstr ""

msgid "#### Benchmark Droonga with two nodes"
msgstr ""

msgid "Before benchmarking, join the second node to the cluster."
msgstr ""

msgid ""
"~~~\n"
"(on node0, node1)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"After that both endpoints `node0` and `node1` work as a Droonga cluster with t"
"wo nodes.\n"
"Make sure that two nodes are actually detected:"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0,node1 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-2nodes.csv\n"
"~~~"
msgstr ""

msgid "Note that two hosts are specified via the `--default-hosts` option."
msgstr ""

msgid ""
"If you send all requests to single endpoint, `droonga-http-server` will become"
" a bottleneck, because it works as a single process for now.\n"
"Moreover, `droonga-http-server` and `droonga-engine` will scramble for CPU res"
"ources.\n"
"To measure the performance of your Droonga cluster effectively, you should ave"
"rage out CPU load per capita."
msgstr ""

msgid ""
"Of course, on the production environment, it should be done by a load balancer"
", but It's a hassle to set up a load balancer for just benchmarking.\n"
"Instead, you can specify multiple endpoint host names as a comma-separated lis"
"t for the `--default-hosts` option."
msgstr ""

msgid "And, the path to the result file also changed."
msgstr ""

msgid ""
"Don't forget to monitor system status of both nodes while benchmarking.\n"
"If only one node is busy and another is idling, something wrong - for example,"
" they are not working as a cluster.\n"
"You also must check the actual cache hit rate of all nodes."
msgstr ""

msgid "#### Benchmark Droonga with three nodes"
msgstr ""

msgid "Before benchmarking, join the last node to the cluster."
msgstr ""

msgid ""
"~~~\n"
"(on node0, node1)\n"
"% sudo droonga-engine-catalog-generate \\\n"
"    --hosts=node0,node1,node2\n"
"% sudo service droonga-engine restart\n"
"% sudo service droonga-http-server restart\n"
"~~~"
msgstr ""

msgid ""
"After that all endpoints `node0`, `node1`, and `node2` work as a Droonga clust"
"er with three nodes.\n"
"Make sure that three nodes are actually detected:"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% curl \"http://node0:10042/droonga/system/status\" | jq .\n"
"{\n"
"  \"nodes\": {\n"
"    \"node0:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node1:10031/droonga\": {\n"
"      \"live\": true\n"
"    },\n"
"    \"node2:10031/droonga\": {\n"
"      \"live\": true\n"
"    }\n"
"  }\n"
"}\n"
"~~~"
msgstr ""

msgid ""
"~~~\n"
"(on node3)\n"
"% drnbench-request-response \\\n"
"    --step=2 \\\n"
"    --start-n-clients=0 \\\n"
"    --end-n-clients=20 \\\n"
"    --duration=30 \\\n"
"    --interval=10 \\\n"
"    --request-patterns-file=$PWD/patterns.txt \\\n"
"    --default-hosts=node0,node1,node2 \\\n"
"    --default-port=10042 \\\n"
"    --output-path=$PWD/droonga-result-3nodes.csv\n"
"~~~"
msgstr ""

msgid ""
"Note that both `--default-hosts` and `--output-path` are changed again.\n"
"Monitoring of system status and checking cache hit rate of all nodes are also "
"important."
msgstr ""

msgid "## Analyze the result"
msgstr ""

msgid "OK, now you have four results:"
msgstr ""

msgid ""
" * `groonga-result.csv`\n"
" * `droonga-result-1node.csv`\n"
" * `droonga-result-2nodes.csv`\n"
" * `droonga-result-3nodes.csv`"
msgstr ""

msgid "[As described](#how-to-analyze), you can analyze them."
msgstr ""

msgid "For example, you can plot a graph from these results like:"
msgstr ""

msgid ""
"![A layered graph of latency](/images/tutorial/benchmark/latency-mixed-1.0.8.p"
"ng)"
msgstr ""

msgid "You can explain this graph of latency as:"
msgstr ""

msgid ""
" * Minimum latency of Droonga is larger than Groonga.\n"
"   There are some overhead in Droonga.\n"
" * Latency of multiple nodes Droonga slowly increases than Groonga.\n"
"   Droonga can process more requests in same time without extra waiting time."
msgstr ""

msgid ""
"![A layered graph of throughput](/images/tutorial/benchmark/throughput-mixed-1"
".0.8.png)"
msgstr ""

msgid "You can explain this graph of throughput as:"
msgstr ""

msgid ""
" * Graphs of Groonga and single node Droonga are alike.\n"
"   There is less performance loss between Groonga and Droonga.\n"
" * Maximum throughput of Droonga is incdeased by number of nodes."
msgstr ""

msgid ""
"(Note: Performance results fluctuate from various factors.\n"
"This graph is just an example on a specific version, specific environment.)"
msgstr ""

msgid "## Conclusion"
msgstr ""

msgid ""
"In this tutorial, you did prepare a reference [Groonga][] server and [Droonga]"
"[] cluster.\n"
"And, you studied how to prepare request patterns, how measure your systems, an"
"d how analyze the result."
msgstr ""

msgid ""
"  [Ubuntu]: http://www.ubuntu.com/\n"
"  [CentOS]: https://www.centos.org/\n"
"  [Droonga]: https://droonga.org/\n"
"  [Groonga]: http://groonga.org/\n"
"  [drnbench]: https://github.com/droonga/drnbench/\n"
"  [wikipedia-search]: https://github.com/droonga/wikipedia-search/\n"
"  [command reference]: ../../reference/commands/"
msgstr ""
