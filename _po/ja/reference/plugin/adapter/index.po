msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-11-20 22:17+0900\n"
"PO-Revision-Date: 2013-12-25 18:27+0900\n"
"Last-Translator: Kouhei Sutou <kou@clear-code.com>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid ""
"---\n"
"title: API set for plugins on the adaption phase\n"
"layout: en\n"
"---"
msgstr ""
"---\n"
"title: AdaptionフェイズでのプラグインAPI\n"
"layout: ja\n"
"---"

msgid ""
"* TOC\n"
"{:toc}"
msgstr ""

msgid "## Abstract {#abstract}"
msgstr "## 概要 {#abstract}"

msgid ""
"Each Droonga Engine plugin can have its *adapter*. On the adaption phase, adap"
"ters can modify both incoming messages (from the Protocol Adapter to the Droon"
"ga Engine, in other words, they are \"request\"s) and outgoing messages (from th"
"e Droonga Engine to the Protocol Adapter, in other words, they are \"response\"s"
")."
msgstr ""

msgid "### How to define an adapter? {#howto-define}"
msgstr ""

msgid "For example, here is a sample plugin named \"foo\" with an adapter:"
msgstr ""

msgid ""
"~~~ruby\n"
"require \"droonga/plugin\""
msgstr ""

msgid ""
"module Droonga\n"
"  module Plugins\n"
"    module FooPlugin\n"
"      Plugin.registry.register(\"foo\", self)"
msgstr ""

msgid ""
"      class Adapter < Droonga::Adapter\n"
"        # operations to configure this adapter\n"
"        message.XXXXXX = XXXXXX"
msgstr ""

msgid ""
"        def adapt_input(input_message)\n"
"          # operations to modify incoming messages\n"
"          input_message.XXXXXX = XXXXXX\n"
"        end"
msgstr ""

msgid ""
"        def adapt_output(output_message)\n"
"          # operations to modify outgoing messages\n"
"          output_message.XXXXXX = XXXXXX\n"
"        end\n"
"      end\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "Steps to define an adapter:"
msgstr ""

msgid ""
" 1. Define a module for your plugin (ex. `Droonga::Plugin::FooPlugin`) and reg"
"ister it as a plugin. (required)\n"
" 2. Define an adapter class (ex. `Droonga::Plugin::FooPlugin::Adapter`) inheri"
"ting [`Droonga::Adapter`](#classes-Droonga-Adapter). (required)\n"
" 3. [Configure conditions to apply the adapter](#howto-configure). (required)\n"
" 4. Define adaption logic for incoming messages as [`#adapt_input`](#classes-D"
"roonga-Adapter-adapt_input). (optional)\n"
" 5. Define adaption logic for outgoing messages as [`#adapt_output`](#classes-"
"Droonga-Adapter-adapt_output). (optional)"
msgstr ""

msgid ""
"For more details, see also the [plugin development tutorial](../../../tutorial"
"/plugin-development/adapter/)."
msgstr ""

msgid "### How an adapter works? {#how-works}"
msgstr ""

msgid "An adapter works like following:"
msgstr ""

msgid ""
" 1. The Droonga Engine starts.\n"
"    * A global instance of the adapter class (ex. `Droonga::Plugin::FooPlugin:"
":Adapter`) is created and it is registered.\n"
"      * The input pattern and the output pattern are registered.\n"
"    * The Droonga Engine starts to wait for incoming messages.\n"
" 2. An incoming message is transferred from the Protocol Adapter to the Droong"
"a Engine.\n"
"    Then, the adaption phase (for an incoming message) starts.\n"
"    * The adapter's [`#adapt_input`](#classes-Droonga-Adapter-adapt_input) is "
"called, if the message matches to the [input matching pattern](#config).\n"
"    * The method can modify the given incoming message, via [its methods](#cla"
"sses-Droonga-InputMessage).\n"
" 3. After all adapters are applied, the adaption phase for an incoming message"
" ends, and the message is transferred to the next \"planning\" phase.\n"
" 4. An outgoing message returns from the previous \"collection\" phase.\n"
"    Then, the adaption phase (for an outgoing message) starts.\n"
"    * The adapter's [`#adapt_output`](#classes-Droonga-Adapter-adapt_output) i"
"s called, if the corresponding incoming message was processed by the adapter a"
"nd the outgoing message matches to the [output matching pattern](#config).\n"
"    * The method can modify the given outgoing message, via [its methods](#cla"
"sses-Droonga-OutputMessage).\n"
" 5. After all adapters are applied, the adaption phase for an outgoing message"
" ends, and the outgoing message is transferred to the Protocol Adapter."
msgstr ""

msgid ""
"As described above, the Droonga Engine creates only one global instance of the"
" adapter class for each plugin.\n"
"You should not keep stateful information for a pair of incoming and outgoing m"
"essages as an instance variable of the adapter.\n"
"Instead, you should give stateful information as a part of the incoming messag"
"e body, and receive it from the body of the corresponding outgoing message."
msgstr ""

msgid ""
"Any error raised from the adapter is handled by the Droonga Engine itself. See"
" also [error handling]."
msgstr ""

msgid "## Configurations {#config}"
msgstr ""

msgid ""
"`input_message.pattern`\n"
": A [matching pattern] for incoming messages.\n"
"  Only messages matched to the given patten are processed by [`#adapt_input`]("
"#classes-Droonga-Adapter-adapt_input)."
msgstr ""

msgid ""
"`output_message.pattern`\n"
": A [matching pattern] for outgoing messages.\n"
"  Only messages matched to the given patten are processed by [`#adapt_output`]"
"(#classes-Droonga-Adapter-adapt_output)."
msgstr ""

msgid "## Classes and methods {#classes}"
msgstr ""

msgid "### `Droonga::Adapter` {#classes-Droonga-Adapter}"
msgstr ""

msgid ""
"This is the common base class of any adapter. Your plugin's adapter class must"
" inherit the class."
msgstr ""

msgid "#### `#adapt_input(input_message)` {#classes-Droonga-Adapter-adapt_input}"
msgstr ""

msgid ""
"Receives an instance of [`Droonga::InputMessage`](#classes-Droonga-InputMessag"
"e) corresponding to an incoming message."
msgstr ""

msgid ""
"By defualt this method does nothing, so you have to override it like following"
":"
msgstr ""

msgid ""
"~~~ruby\n"
"module FooPlugin\n"
"  class Adapter < Droonga::Adapter\n"
"    def adapt_input(input_message)\n"
"      input_message.body[\"query\"] = \"fixed query\"\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid "#### `#adapt_output(output_message)` {#classes-Droonga-Adapter-adapt_output}"
msgstr ""

msgid ""
"Receives an instance of [`Droonga::OutputMessage`](#classes-Droonga-InputMessa"
"ge) corresponding to an outgoing message."
msgstr ""

msgid ""
"~~~ruby\n"
"module FooPlugin\n"
"  class Adapter < Droonga::Adapter\n"
"    def adapt_output(output_message)\n"
"      output_message.status_code = StatusCode::OK\n"
"    end\n"
"  end\n"
"end\n"
"~~~"
msgstr ""

msgid ""
"### `Droonga::Plugin::Metadata::AdapterMessage` {#classes-Droonga-Plugin-Metad"
"ata-AdapterMessage}"
msgstr ""

msgid "(under construction)"
msgstr ""

msgid ""
"#### `#input_pattern`, `#input_pattern=(pattern)` {#classes-Droonga-Plugin-Met"
"adata-AdapterMessage-input_pattern}"
msgstr ""

msgid ""
"#### `#output_pattern`, `#output_pattern=(pattern)` {#classes-Droonga-Plugin-M"
"etadata-AdapterMessage-output_pattern}"
msgstr ""

msgid "### `Droonga::InputMessage` {#classes-Droonga-InputMessage}"
msgstr ""

msgid "#### `#command`, `#command=(command)` {#classes-Droonga-InputMessage-command}"
msgstr ""

msgid "#### `#body`, `#body=(body)` {#classes-Droonga-InputMessage-body}"
msgstr ""

msgid "### `Droonga::OutputMessage` {#classes-Droonga-OutputMessage}"
msgstr ""

msgid ""
"#### `#status_code`, `#status_code=(status_code)` {#classes-Droonga-OutputMess"
"age-status_code}"
msgstr ""

msgid "#### `#errors`, `#errors=(errors)` {#classes-Droonga-OutputMessage-errors}"
msgstr ""

msgid "#### `#body`, `#body=(body)` {#classes-Droonga-OutputMessage-body}"
msgstr ""

msgid ""
"  [matching pattern]: ../matching-pattern/\n"
"  [error handling]: ../error/"
msgstr ""
