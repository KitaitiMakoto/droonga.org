---
title: API set for plugins on the handling phase
layout: en
---

{% comment %}
##############################################
  THIS FILE IS AUTOMATICALLY GENERATED FROM
  "_po/ja/reference/plugin/handler/index.po"
  DO NOT EDIT THIS FILE MANUALLY!
##############################################
{% endcomment %}


* TOC
{:toc}


## 概要 {#abstract}

Each Droonga Engine plugin can have its *handler*.
On the handling phase, handlers can process a request and return a result.


### How to define a handler? {#howto-define}

For example, here is a sample plugin named "foo" with a handler:

~~~ruby
require "droonga/plugin"

module Droonga::Plugins::FooPlugin
  extend Plugin
  register("foo")

  define_single_step do |step|
    step.name = "foo"
    step.handler = :Handler
    step.collector = Collectors::And
  end

  class Handler < Droonga::Handler
    def handle(message)
      # operations to process a request
    end
  end
end
~~~

Steps to define a handler:

 1. Define a module for your plugin (ex. `Droonga::Plugins::FooPlugin`) and register it as a plugin. (required)
 2. Define a "single step" corresponding to the handler you are going to implement. (required)
 2. Define a handler class (ex. `Droonga::Plugins::FooPlugin::Handler`) inheriting [`Droonga::Handler`](#classes-Droonga-Handler). (required)
 4. Define handling logic for requests as [`#handle`](#classes-Droonga-Handler-handle). (optional)

See also the [plugin development tutorial](../../../tutorial/plugin-development/handler/).


### How a handler works? {#how-works}

A handler works like following:

 1. The Droonga Engine starts.
    * Your custom steps are registered.
      Your custom handler classes also.
    * Then the Droonga Engine starts to wait for request messages.
 2. A request message is transferred from the adaption phase.
    Then, the processing phase starts.
    * The Droonga Engine finds a step definition from the message type.
    * The Droonga Engine builds a "single step" based on the registered definition.
    * A "single step" creates an instance of the registered handler class.
      Then the Droonga Engine enters to the handling phase.
      * The handler's [`#handle`](#classes-Droonga-Handler-handle) is called with a task massage including the request.
        * The method can process the given incoming message as you like.
        * The method returns a result value, as the output.
      * After the handler finishes, the handling phase for the task message (and the request) ends.
    * If no "step" is found for the type, nothing happens.
    * All "step"s finish their task, the processing phase for the request ends.

As described above, the Droonga Engine creates an instance of the handler class for each request.

Any error raised from the handler is handled by the Droonga Engine itself. See also [error handling][].


## 設定 {#config}

`action.synchronous` (boolean, optional, default=false)
: (TBD)


## Classes and methods {#classes}

### `Droonga::Handler` {#classes-Droonga-Handler}

This is the common base class of any handler. Your plugin's handler class must inherit this.

#### `#handle(message)` {#classes-Droonga-Handler-handle}

This method receives a [`Droonga::HandlerMessage`](#classes-Droonga-HandlerMessage) wrapped task message.

(TBD)

### `Droonga::HandlerMessage` {#classes-Droonga-HandlerMessage}

#### `#request` {#classes-Droonga-HandlerMessage-request}

Returns the request message.

(TBD)

  [error handling]: ../error/
